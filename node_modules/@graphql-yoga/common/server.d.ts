import { GraphQLSchema } from 'graphql';
import { Plugin, GetEnvelopedFn, UseMaskedErrorsOpts } from '@envelop/core';
import { ExecutionResult, IResolvers, TypeSource } from '@graphql-tools/utils';
import { CORSOptions, GraphQLServerInject, YogaInitialContext, YogaLogger } from './types';
import { GraphiQLOptions } from './graphiql';
import { Request } from 'cross-undici-fetch';
interface OptionsWithPlugins<TContext> {
    /**
     * Envelop Plugins
     * @see https://envelop.dev/plugins
     */
    plugins: Array<Plugin<TContext> | Plugin | {}>;
}
/**
 * Configuration options for the server
 */
export declare type YogaServerOptions<TAdditionalContext, TRootValue> = {
    /**
     * Enable/disable logging or provide a custom logger.
     * @default true
     */
    logging?: boolean | YogaLogger;
    /**
     * Prevent leaking unexpected errors to the client. We highly recommend enabling this in production.
     * If you throw `GraphQLYogaError`/`EnvelopError` within your GraphQL resolvers then that error will be sent back to the client.
     *
     * You can lean more about this here:
     * @see https://graphql-yoga.vercel.app/docs/features/error-masking
     *
     * Default: `true`
     */
    maskedErrors?: boolean | UseMaskedErrorsOpts;
    /**
     * Context
     */
    context?: ((initialContext: YogaInitialContext) => Promise<TAdditionalContext> | TAdditionalContext) | Promise<TAdditionalContext> | TAdditionalContext;
    cors?: ((request: Request) => CORSOptions) | CORSOptions | boolean;
    /**
     * GraphiQL options
     *
     * Default: `true`
     */
    graphiql?: GraphiQLOptions | false;
    schema?: GraphQLSchema | {
        typeDefs: TypeSource;
        resolvers?: IResolvers<TRootValue, TAdditionalContext & YogaInitialContext> | Array<IResolvers<TRootValue, TAdditionalContext & YogaInitialContext>>;
    };
} & Partial<OptionsWithPlugins<TAdditionalContext>>;
export declare function getDefaultSchema(): GraphQLSchema;
/**
 * Base class that can be extended to create a GraphQL server with any HTTP server framework.
 * @internal
 */
export declare class YogaServer<TAdditionalContext extends Record<string, any>, TRootValue> {
    /**
     * Instance of envelop
     */
    readonly getEnveloped: GetEnvelopedFn<TAdditionalContext & YogaInitialContext>;
    logger: YogaLogger;
    private readonly corsOptionsFactory;
    protected readonly graphiql: GraphiQLOptions | false;
    constructor(options?: YogaServerOptions<TAdditionalContext, TRootValue>);
    getCORSResponseHeaders(request: Request): Record<string, string>;
    handleOptions(request: Request): Response;
    private id;
    handleRequest: (request: Request, additionalContext?: TAdditionalContext | undefined) => Promise<Response>;
    /**
     * Testing utility to mock http request for GraphQL endpoint
     *
     *
     * Example - Test a simple query
     * ```ts
     * const response = await yoga.inject({
     *  document: "query { ping }",
     * })
     * expect(response.statusCode).toBe(200)
     * expect(response.data.ping).toBe('pong')
     * ```
     **/
    inject<TData = any, TVariables = any>({ document, variables, operationName, headers, }: GraphQLServerInject<TData, TVariables>): Promise<{
        response: Response;
        executionResult: ExecutionResult<TData> | null;
    }>;
}
export declare function createServer<TAdditionalContext extends Record<string, any> = Record<string, any>, TRootValue = {}>(options?: YogaServerOptions<TAdditionalContext, TRootValue>): YogaServer<TAdditionalContext, TRootValue>;
export {};
